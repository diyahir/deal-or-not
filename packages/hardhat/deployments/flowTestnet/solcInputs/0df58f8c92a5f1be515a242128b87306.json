{
  "language": "Solidity",
  "sources": {
    "@onflow/flow-sol-utils/src/cadence-arch/CadenceArchUtils.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.19;\n\n/**\n * @dev This contract is a base contract to facilitate easier consumption of the Cadence Arch pre-compiles. Implementing\n * contracts can use this contract to fetch the current Flow block height and fetch random numbers from the Cadence\n * runtime.\n */\nlibrary CadenceArchUtils {\n    // Cadence Arch pre-compile address\n    address public constant cadenceArch = 0x0000000000000000000000010000000000000001;\n\n    /**\n     * @dev This method returns the current Flow block height.\n     *\n     * @return flowBlockHeight The current Flow block height.\n     */\n    function _flowBlockHeight() internal view returns (uint64) {\n        (bool ok, bytes memory data) = cadenceArch.staticcall(abi.encodeWithSignature(\"flowBlockHeight()\"));\n        require(ok, \"Unsuccessful call to Cadence Arch pre-compile when fetching Flow block height\");\n\n        uint64 output = abi.decode(data, (uint64));\n        return output;\n    }\n\n    /**\n     * @dev This method uses the Cadence Arch pre-compiles to return a random number from the Cadence runtime. Consumers\n     * should know this is a revertible random source and should only be used as a source of randomness when called by\n     * trusted callers - i.e. with trust that the caller won't revert on result.\n     *\n     * @return randomSource The random source.\n     */\n    function _revertibleRandom() internal view returns (uint64) {\n        (bool ok, bytes memory data) = cadenceArch.staticcall(abi.encodeWithSignature(\"revertibleRandom()\"));\n        require(ok, \"Unsuccessful call to Cadence Arch pre-compile when fetching revertible random number\");\n\n        uint64 output = abi.decode(data, (uint64));\n        return output;\n    }\n\n    /**\n     * @dev This method uses the Cadence Arch pre-compiles to returns a random source for a given Flow block height.\n     * The provided height must be at least one block in the past.\n     *\n     * @param flowHeight The Flow block height for which to get the random source.\n     * @return randomSource The random source for the given Flow block height.\n     */\n    function _getRandomSource(uint64 flowHeight) internal view returns (bytes32) {\n        (bool ok, bytes memory data) =\n            cadenceArch.staticcall(abi.encodeWithSignature(\"getRandomSource(uint64)\", flowHeight));\n        require(ok, \"Unsuccessful call to Cadence Arch pre-compile when fetching random source\");\n\n        // Decode the result as bytes32 & return\n        bytes32 result = abi.decode(data, (bytes32));\n        return result;\n    }\n}\n"
    },
    "@onflow/flow-sol-utils/src/random/CadenceRandomConsumer.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.19;\n\nimport {CadenceArchUtils} from \"../cadence-arch/CadenceArchUtils.sol\";\nimport {Xorshift128plus} from \"./Xorshift128plus.sol\";\n\n/**\n * @dev This contract is a base contract for secure consumption of Flow's protocol-native randomness via the Cadence\n * Arch pre-compile. Implementing contracts benefit from the commit-reveal scheme below, ensuring that callers cannot\n * revert on undesirable random results.\n */\nabstract contract CadenceRandomConsumer {\n    using Xorshift128plus for Xorshift128plus.PRG;\n\n    // A struct to store the request details\n    struct Request {\n        // The Flow block height at which the request was made\n        uint64 flowHeight;\n        // The EVM block height at which the request was made\n        uint256 evmHeight;\n        // Whether the request has been fulfilled\n        bool fulfilled;\n    }\n\n    // Events\n    event RandomnessRequested(uint256 indexed requestId, uint64 flowHeight, uint256 evmHeight);\n    event RandomnessSourced(uint256 indexed requestId, uint64 flowHeight, uint256 evmHeight, bytes32 randomSource);\n    event RandomnessFulfilled(uint256 indexed requestId, uint64 randomResult);\n\n    // A list of requests where each request is identified by its index in the array\n    Request[] private _requests;\n    // A counter to keep track of the number of requests made, serving as the request ID\n    uint256 private _requestCounter;\n\n    ///////////////////\n    // PUBLIC FUNCTIONS\n    ///////////////////\n\n    /**\n     * @dev This method checks if a request can be fulfilled.\n     *\n     * @param requestId The ID of the randomness request to check.\n     * @return canFulfill Whether the request can be fulfilled.\n     */\n    function canFulfillRequest(uint256 requestId) public view returns (bool) {\n        uint256 requestIndex = requestId - 1;\n        if (requestIndex >= _requests.length) {\n            return false;\n        }\n        Request storage request = _requests[requestIndex];\n        uint64 flowHeight = CadenceArchUtils._flowBlockHeight();\n        return !request.fulfilled && request.flowHeight < flowHeight;\n    }\n\n    /////////////////////\n    // INTERNAL FUNCTIONS\n    /////////////////////\n\n    /**\n     * @dev This method returns a ***REVERTIBLE** random number in the range [min, max].\n     * NOTE: The fact that this method is revertible means that it should only be used in cases where the initiating\n     * caller is trusted not to revert on the result.\n     *\n     * @param min The minimum value of the range (inclusive).\n     * @param max The maximum value of the range (inclusive).\n     * @return random The random number in the range [min, max].\n     */\n    function _getRevertibleRandomInRange(uint64 min, uint64 max) internal view returns (uint64) {\n        bytes memory seed = abi.encodePacked(_aggregateRevertibleRandom256());\n        bytes memory salt = abi.encodePacked(block.number);\n\n        // Instantiate a PRG with the aggregate bytes and salt with current block number\n        Xorshift128plus.PRG memory prg;\n        prg.seed(seed, salt);\n\n        return _getNumberInRange(prg, min, max);\n    }\n\n    /**\n     * ----- COMMIT STEP -----\n     */\n\n    /**\n     * @dev This method serves as the commit step in this contract's commit-reveal scheme\n     *\n     * Here a caller places commits at Flow block n to reveal a random number at >= block n+1\n     * This is because the random source for a Flow block is not available until after the finalization of that block.\n     * Implementing contracts may wish to affiliate the request ID with the caller's address or some other identifier\n     * so the relevant request can be fulfilled.\n     * Emits a {RandomnessRequested} event.\n     *\n     * @return requestId The ID of the request.\n     */\n    function _requestRandomness() internal returns (uint256) {\n        // Identify the request by the current request counter, incrementing first so implementations can use 0 for\n        // invalid requests - e.g. myRequests[msg.sender] == 0 means the caller has no pending requests\n        _requestCounter++;\n        uint256 requestId = _requestCounter;\n        // Store the heights at which the request was made. Note that the Flow block height and EVM block height are\n        // not the same. But since Flow blocks ultimately determine usage of secure randomness, we gate requests by\n        // Flow block height.\n        Request memory request = Request(CadenceArchUtils._flowBlockHeight(), block.number, false);\n\n        // Store the request in the list of requests\n        _requests.push(request);\n\n        emit RandomnessRequested(requestId, request.flowHeight, request.evmHeight);\n\n        // Finally return the request ID\n        return requestId;\n    }\n\n    /**\n     * ----- REVEAL STEP -----\n     */\n\n    /**\n     * @dev This method fulfills a random request and returns a random number as a uint64.\n     *\n     * @param requestId The ID of the randomness request to fulfill.\n     * @return randomResult The random number.\n     */\n    function _fulfillRandomRequest(uint256 requestId) internal returns (uint64) {\n        bytes memory seed = abi.encodePacked(_fulfillRandomness(requestId));\n        bytes memory salt = abi.encodePacked(requestId);\n\n        // Instantiate a PRG, seeding with the random value and salting with the request ID\n        Xorshift128plus.PRG memory prg;\n        prg.seed(seed, salt);\n\n        uint64 randomResult = prg.nextUInt64();\n\n        emit RandomnessFulfilled(requestId, randomResult);\n\n        return randomResult;\n    }\n\n    /**\n     * @dev This method fulfills a random request and safely returns an unbiased random number in the range inclusive [min, max].\n     *\n     * @param requestId The ID of the randomness request to fulfill.\n     * @param min The minimum value of the range (inclusive).\n     * @param max The maximum value of the range (inclusive).\n     * @return randomResult The random number in the inclusive range [min, max].\n     */\n    function _fulfillRandomInRange(uint256 requestId, uint64 min, uint64 max) internal returns (uint64) {\n        // Ensure that the request is fulfilled at a Flow block height greater than the one at which the request was made\n        // Get the random source for the Flow block at which the request was made\n        bytes memory seed = abi.encodePacked(_fulfillRandomness(requestId));\n        bytes memory salt = abi.encodePacked(requestId);\n\n        // Instantiate a PRG with the random source and the request ID\n        Xorshift128plus.PRG memory prg;\n        prg.seed(seed, salt);\n\n        uint64 randomResult = _getNumberInRange(prg, min, max); // Get a random number in the range [min, max]\n\n        emit RandomnessFulfilled(requestId, randomResult);\n\n        return randomResult;\n    }\n\n    ////////////////////\n    // PRIVATE FUNCTIONS\n    ////////////////////\n\n    /**\n     * @dev This method returns a number in the range [min, max] from the given value with a variation on rejection\n     * sampling.\n     * NOTE: You may be tempted to simply use `value % (max - min + 1)` to get a number in a range. However, this\n     * method is not secure is susceptible to the modulo bias. This method provides an unbiased alternative for secure\n     * secure use of randomness.\n     *\n     * @param prg The PRG to use for generating the random number.\n     * @param min The minimum value of the range (inclusive).\n     * @param max The maximum value of the range (inclusive).\n     * @return random The random number in the range [min, max].\n     */\n    function _getNumberInRange(Xorshift128plus.PRG memory prg, uint64 min, uint64 max) private pure returns (uint64) {\n        require(max > min, \"Max must be greater than min\");\n\n        uint64 range = max - min;\n        uint64 bitsRequired = _mostSignificantBit(range); // Number of bits needed to cover the range\n        uint256 mask = (1 << bitsRequired) - 1; // Create a bitmask to extract relevant bits\n\n        uint256 shiftLimit = 256 / bitsRequired; // Number of shifts needed to cover 256 bits\n        uint256 shifts = 0; // Initialize shift counter\n\n        uint64 candidate = 0; // Initialize candidate\n        uint256 value = prg.nextUInt256(); // Assign the first 256 bits of randomness\n\n        while (true) {\n            candidate = uint64(value & mask); // Apply the bitmask to extract bits\n            if (candidate <= range) {\n                break; // Found a suitable candidate within the target range\n            }\n\n            // Shift by the number of bits covered by the mask\n            value = value >> bitsRequired;\n            shifts++;\n\n            // Get a new value if we've exhausted the current one\n            if (shifts == shiftLimit) {\n                value = prg.nextUInt256();\n                shifts = 0;\n            }\n        }\n\n        // Scale candidate to the range [min, max]\n        return min + candidate;\n    }\n\n    /**\n     * @dev This method serves as the reveal step in this contract's commit-reveal scheme\n     *\n     * Here a caller reveals a random number at least one block after the commit block\n     * This is because the random source for a Flow block is not available until after the finalization of that block.\n     * Note that the random source for a given Flow block is singular. In order to ensure that requests made at the same\n     * block height are unique, implementing contracts should use some pseudo-random method to generate a unique value\n     * from the seed along with a salt.\n     * Emits a {RandomnessFulfilled} event.\n     *\n     * @param requestId The ID of the randomness request to fulfill.\n     * @return randomResult The random value generated from the Flow block.\n     */\n    function _fulfillRandomness(uint256 requestId) private returns (bytes32) {\n        // Get the request details. Recall that request IDs are 1-indexed to allow for 0 to be used as an invalid value\n        uint256 requestIndex = requestId - 1;\n        require(requestIndex < _requests.length, \"Invalid request ID - value exceeds the number of existing requests\");\n\n        // Access & validate the request\n        Request storage request = _requests[requestIndex];\n        _validateRequest(request);\n        request.fulfilled = true; // Mark the request as fulfilled\n\n        // Get the random source for the Flow block at which the request was made, emit & return\n        bytes32 randomSource = CadenceArchUtils._getRandomSource(request.flowHeight);\n\n        emit RandomnessSourced(requestId, request.flowHeight, request.evmHeight, randomSource);\n\n        return randomSource;\n    }\n\n    /**\n     * @dev This method aggregates 256 bits of randomness by calling _revertibleRandom() 4 times.\n     *\n     * @return randomValue The aggregated 256 bits of randomness.\n     */\n    function _aggregateRevertibleRandom256() private view returns (uint256) {\n        // Call _revertibleRandom() 4 times to aggregate 256 bits of randomness\n        uint256 randomValue = uint256(CadenceArchUtils._revertibleRandom());\n        randomValue |= (uint256(CadenceArchUtils._revertibleRandom()) << 64);\n        randomValue |= (uint256(CadenceArchUtils._revertibleRandom()) << 128);\n        randomValue |= (uint256(CadenceArchUtils._revertibleRandom()) << 192);\n        return randomValue;\n    }\n\n    /**\n     * @dev This method returns the most significant bit of a uint64.\n     *\n     * @param x The input value.\n     * @return bits The most significant bit of the input value.\n     */\n    function _mostSignificantBit(uint64 x) private pure returns (uint64) {\n        uint64 bits = 0;\n        while (x > 0) {\n            x >>= 1;\n            bits++;\n        }\n        return bits;\n    }\n\n    /**\n     * @dev This method validates a given request, ensuring that it has not been fulfilled and that the Flow block height\n     * has passed.\n     *\n     * @param request The request to validate.\n     */\n    function _validateRequest(Request storage request) private view {\n        require(!request.fulfilled, \"Request already fulfilled\");\n        require(\n            request.flowHeight < CadenceArchUtils._flowBlockHeight(),\n            \"Cannot fulfill request until subsequent Flow network block height\"\n        );\n    }\n}\n"
    },
    "@onflow/flow-sol-utils/src/random/Xorshift128plus.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.19;\n\n/**\n * @dev This library implements the Xorshift128+ pseudo-random number generator (PRG) algorithm.\n */\nlibrary Xorshift128plus {\n    /**\n     * @dev While not limited to 128 bits of state, this PRG is largely informed by xorshift128+\n     */\n    struct PRG {\n        uint64 state0;\n        uint64 state1;\n    }\n\n    /**\n     * @dev Initializer for PRG struct\n     *\n     * @param prg The PRG struct to seed\n     * @param sourceOfRandomness The entropy bytes used to seed the PRG. It is recommended to use at least 16\n     * bytes of entropy.\n     * @param salt The bytes used to salt the source of randomness\n     */\n    function seed(PRG memory prg, bytes memory sourceOfRandomness, bytes memory salt) internal pure {\n        require(\n            sourceOfRandomness.length >= 16, \"At least 16 bytes of entropy should be used when initializing the PRG\"\n        );\n        bytes memory tmp = abi.encodePacked(sourceOfRandomness, salt);\n        bytes32 hash = keccak256(tmp);\n\n        prg.state0 = _bigEndianBytesToUint64(abi.encodePacked(hash), 0);\n        prg.state1 = _bigEndianBytesToUint64(abi.encodePacked(hash), 8);\n\n        _requireNonZero(prg);\n    }\n\n    /**\n     * @dev Advances the PRG state and generates the next UInt64 value\n     * See https://arxiv.org/pdf/1404.0390.pdf for implementation details and reasoning for triplet selection.\n     * Note that state only advances when this function is called from a transaction. Calls from within a script\n     * will not advance state and will return the same value.\n     *\n     * @return The next UInt64 value\n     */\n    function nextUInt64(PRG memory prg) internal pure returns (uint64) {\n        _requireNonZero(prg);\n\n        uint64 a = prg.state0;\n        uint64 b = prg.state1;\n\n        prg.state0 = b;\n\n        // Allow the states to wrap around\n        unchecked {\n            a ^= a << 23; // a\n            a ^= a >> 17; // b\n            a ^= b ^ (b >> 26); // c\n        }\n\n        prg.state1 = a;\n\n        unchecked {\n            return a + b; // Addition with wrapping\n        }\n    }\n\n    /**\n     * @dev Advances the PRG state and generates the next UInt256 value by concatenating 4 UInt64 values\n     *\n     * @return The next UInt256 value\n     */\n    function nextUInt256(PRG memory prg) internal pure returns (uint256) {\n        uint256 result = uint256(nextUInt64(prg));\n        result |= uint256(nextUInt64(prg)) << 64;\n        result |= uint256(nextUInt64(prg)) << 128;\n        result |= uint256(nextUInt64(prg)) << 192;\n        return result;\n    }\n\n    /**\n     * @dev Helper function to convert an array of big endian bytes to Word64\n     *\n     * @param input The bytes to convert\n     * @param start The index of the first byte to convert\n     *\n     * @return The Word64 value\n     */\n    function _bigEndianBytesToUint64(bytes memory input, uint256 start) private pure returns (uint64) {\n        require(input.length >= start + 8, \"Invalid byte length\");\n        uint64 value = 0;\n        for (uint256 i = 0; i < 8; i++) {\n            value = (value << 8) | uint64(uint8(input[start + i]));\n        }\n        return value;\n    }\n\n    function _requireNonZero(PRG memory prg) private pure {\n        require(prg.state0 != 0 || prg.state1 != 0, \"PRG initial state is 0 - must be initialized as non-zero\");\n    }\n}\n"
    },
    "contracts/interfaces/IVRF.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IVRF {\n    function requestRandomNumber(bytes32) external payable returns (uint256);\n\n    function getRandomNumber(uint256 requestId) external returns (uint256);\n}\n"
    },
    "contracts/vrf/flow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../interfaces/IVRF.sol\";\nimport {CadenceRandomConsumer} from \"@onflow/flow-sol-utils/src/random/CadenceRandomConsumer.sol\";\n\n/**\n * @dev Flow VRF implementation using Flow's native secure randomness\n * Implements the IVRF interface for compatibility with DealOrNot contract\n */\ncontract FlowVRF is IVRF, CadenceRandomConsumer {\n    event RandomRequested(bytes32 indexed requestId, uint256 indexed flowRequestId);\n    event RandomFulfilled(bytes32 indexed requestId, uint256 randomNumber);\n\n    /**\n     * @dev Request a random number using Flow's native VRF\n     * @param _userRandomNumber Additional entropy from user (can be used for extra randomness)\n     * @return requestId The unique identifier for this random number request\n     */\n    function requestRandomNumber(bytes32 _userRandomNumber) external payable override returns (uint256) {\n        // Generate a unique request ID\n        // Request randomness from Flow's native VRF\n        uint256 flowRequestId = _requestRandomness();\n\n        return flowRequestId;\n    }\n\n    /**\n     * @dev Get the random number for a request\n     * @param requestId The request ID returned by requestRandomNumber\n     * @return The random number from Flow's VRF\n     */\n    function getRandomNumber(uint256 requestId) external override returns (uint256) {\n        uint256 randomNumber = _fulfillRandomInRange(requestId, 0, type(uint64).max);\n\n        return randomNumber;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}